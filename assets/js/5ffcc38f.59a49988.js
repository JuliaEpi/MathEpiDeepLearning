"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6319],{3905:function(a,e,t){t.d(e,{Zo:function(){return u},kt:function(){return h}});var r=t(7294);function i(a,e,t){return e in a?Object.defineProperty(a,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):a[e]=t,a}function n(a,e){var t=Object.keys(a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(a);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(a,e).enumerable}))),t.push.apply(t,r)}return t}function l(a){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?n(Object(t),!0).forEach((function(e){i(a,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(t)):n(Object(t)).forEach((function(e){Object.defineProperty(a,e,Object.getOwnPropertyDescriptor(t,e))}))}return a}function p(a,e){if(null==a)return{};var t,r,i=function(a,e){if(null==a)return{};var t,r,i={},n=Object.keys(a);for(r=0;r<n.length;r++)t=n[r],e.indexOf(t)>=0||(i[t]=a[t]);return i}(a,e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(a);for(r=0;r<n.length;r++)t=n[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(a,t)&&(i[t]=a[t])}return i}var o=r.createContext({}),s=function(a){var e=r.useContext(o),t=e;return a&&(t="function"==typeof a?a(e):l(l({},e),a)),t},u=function(a){var e=s(a.components);return r.createElement(o.Provider,{value:e},a.children)},c={inlineCode:"code",wrapper:function(a){var e=a.children;return r.createElement(r.Fragment,{},e)}},m=r.forwardRef((function(a,e){var t=a.components,i=a.mdxType,n=a.originalType,o=a.parentName,u=p(a,["components","mdxType","originalType","parentName"]),m=s(t),h=i,k=m["".concat(o,".").concat(h)]||m[h]||c[h]||n;return t?r.createElement(k,l(l({ref:e},u),{},{components:t})):r.createElement(k,l({ref:e},u))}));function h(a,e){var t=arguments,i=e&&e.mdxType;if("string"==typeof a||i){var n=t.length,l=new Array(n);l[0]=m;var p={};for(var o in e)hasOwnProperty.call(e,o)&&(p[o]=e[o]);p.originalType=a,p.mdxType="string"==typeof a?a:i,l[1]=p;for(var s=2;s<n;s++)l[s]=t[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},5593:function(a,e,t){t.r(e),t.d(e,{assets:function(){return u},contentTitle:function(){return o},default:function(){return h},frontMatter:function(){return p},metadata:function(){return s},toc:function(){return c}});var r=t(7462),i=t(3366),n=(t(7294),t(3905)),l=["components"],p={sidebar_position:1},o=void 0,s={unversionedId:"AI4Science/tensorcomputation",id:"AI4Science/tensorcomputation",title:"tensorcomputation",description:"- Tensor and matrix computation",source:"@site/docs/AI4Science/tensorcomputation.md",sourceDirName:"AI4Science",slug:"/AI4Science/tensorcomputation",permalink:"/MathEpiDeepLearning/docs/AI4Science/tensorcomputation",editUrl:"https://github.com/Song921012/MathEpiDeepLearning/docs/AI4Science/tensorcomputation.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Static Web Tools",permalink:"/MathEpiDeepLearning/docs/HowToResearch/Exhibition"},next:{title:"autodiff",permalink:"/MathEpiDeepLearning/docs/AI4Science/autodiff"}},u={},c=[{value:'<span id="head17">3.1.3. Matrix and Tensor computation</span>',id:"313-matrix-and-tensor-computation",level:3},{value:'<span id="head18">Special Matrix and Arrays</span>',id:"special-matrix-and-arrays",level:4},{value:'<span id="head80"> Computation </span>',id:"-computation-",level:4},{value:'<span id="head19"> Eigenvalues and Solvers </span>',id:"-eigenvalues-and-solvers-",level:4},{value:'<span id="head20">Maps and Operators</span>',id:"maps-and-operators",level:4},{value:'<span id="head21">Matrxi Equations</span>',id:"matrxi-equations",level:4},{value:'<span id="head22">Kronecker-based algebra</span>',id:"kronecker-based-algebra",level:4}],m={toc:c};function h(a){var e=a.components,t=(0,i.Z)(a,l);return(0,n.kt)("wrapper",(0,r.Z)({},m,t,{components:e,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"descriptions"},"Descriptions"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Tensor and matrix computation"),(0,n.kt)("li",{parentName:"ul"},"Linear Solvers"),(0,n.kt)("li",{parentName:"ul"},"Nonlinear Solvers"),(0,n.kt)("li",{parentName:"ul"},"Matrix Equations"),(0,n.kt)("li",{parentName:"ul"},"HPC")),(0,n.kt)("h1",{id:"mkl-labpack"},"MKL Labpack"),(0,n.kt)("h1",{id:"petsc-and-slepc"},"PETSc and SLEPc"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://petsc.org/release/"},"PETSc 3.17 \u2014 PETSc 3.17.3 documentation")),(0,n.kt)("p",null,"Scalable Library for Eigenvalue Problem Computations",(0,n.kt)("a",{parentName:"p",href:"https://gitlab.com/slepc/slepc"},"SLEPc / slepc \xb7 GitLab")),(0,n.kt)("h1",{id:"suitesparse"},"suitesparse"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://people.engr.tamu.edu/davis/suitesparse.html"},"suitesparse : a suite of sparse matrix software")),(0,n.kt)("h1",{id:"pardiso-and-mklpardiso"},"Pardiso and MKLPardiso"),(0,n.kt)("h1",{id:"hsl"},"HSL"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://www.hsl.rl.ac.uk/"},"HSL Mathematical Software Library")),(0,n.kt)("h1",{id:"mumps"},"MUMPS"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"http://mumps.enseeiht.fr/"},"MUMPS : a parallel sparse direct solver")),(0,n.kt)("h1",{id:"cusolvers"},"cuSolvers"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://docs.nvidia.com/cuda/cusolver/index.html"},"cuSOLVER :: CUDA Toolkit Documentation")),(0,n.kt)("h3",{id:"313-matrix-and-tensor-computation"},(0,n.kt)("span",{id:"head17"},"3.1.3. Matrix and Tensor computation")),(0,n.kt)("p",null,"Matrix organization"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaArrays"},"JuliaArrays")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaArrays/StaticArrays.jl"},"JuliaArrays/StaticArrays.jl: Statically sized arrays for Julia"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaArrays/ArrayInterface.jl"},"JuliaArrays/ArrayInterface.jl: Designs for new Base array interface primitives, used widely through scientific machine learning (SciML) and other organizations"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaArrays/StructArrays.jl"},"JuliaArrays/StructArrays.jl: Efficient implementation of struct arrays in Julia"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaArrays/LazyArrays.jl"},"JuliaArrays/LazyArrays.jl: Lazy arrays and linear algebra in Julia"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaArrays/AxisArrays.jl"},"JuliaArrays/AxisArrays.jl: Performant arrays where each dimension can have a named axis with values"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaArrays/OffsetArrays.jl"},"JuliaArrays/OffsetArrays.jl: Fortran-like arrays with arbitrary, zero or negative starting indices."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaArrays/BlockArrays.jl"},"JuliaArrays/BlockArrays.jl: BlockArrays for Julia"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaArrays/ArraysOfArrays.jl"},"JuliaArrays/ArraysOfArrays.jl: Efficient storage and handling of nested arrays in Julia"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaArrays/InfiniteArrays.jl"},"JuliaArrays/InfiniteArrays.jl: A Julia package for representing infinite-dimensional arrays"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaArrays/FillArrays.jl"},"JuliaArrays/FillArrays.jl: Julia package for lazily representing matrices filled with a single entry")))),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaMatrices"},"JuliaMatrices")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaMatrices/BandedMatrices.jl"},"JuliaMatrices/BandedMatrices.jl: A Julia package for representing banded matrices"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaMatrices/BlockBandedMatrices.jl"},"JuliaMatrices/BlockBandedMatrices.jl: A Julia package for representing block-banded matrices and banded-block-banded matrices"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaMatrices/SpecialMatrices.jl"},"JuliaMatrices/SpecialMatrices.jl: Julia package for working with special matrix types."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaMatrices/InfiniteLinearAlgebra.jl"},"JuliaMatrices/InfiniteLinearAlgebra.jl: A Julia repository for linear algebra with infinite matrices")))),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/RalphAS"},"RalphAS")),(0,n.kt)("p",null,"Good",(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaLinearAlgebra"},"JuliaLinearAlgebra")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaSparse"},"JuliaSparse")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaLang/SparseArrays.jl"},"JuliaLang/SparseArrays.jl: SparseArrays.jl is a Julia stdlib")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/SciML/LabelledArrays.jl"},"SciML/LabelledArrays.jl: Arrays which also have a label for each element for easy scientific machine learning (SciML)")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/SciML/RecursiveArrayTools.jl"},"SciML/RecursiveArrayTools.jl: Tools for easily handling objects like arrays of arrays and deeper nestings in scientific machine learning (SciML) and other applications")),(0,n.kt)("p",null,"Python:"),(0,n.kt)("p",null,"numpy"),(0,n.kt)("p",null,"numba"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/scikit-hep/awkward-1.0"},"scikit-hep/awkward-1.0: Manipulate JSON-like data with NumPy-like idioms.")),(0,n.kt)("h4",{id:"special-matrix-and-arrays"},(0,n.kt)("span",{id:"head18"},"Special Matrix and Arrays")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaMatrices/SpecialMatrices.jl"},"JuliaMatrices/SpecialMatrices.jl: Julia package for working with special matrix types.")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/SciML/LabelledArrays.jl"},"SciML/LabelledArrays.jl: Arrays which also have a label for each element for easy scientific machine learning (SciML)")),(0,n.kt)("h4",{id:"-computation-"},(0,n.kt)("span",{id:"head80"}," Computation ")),(0,n.kt)("p",null,"BLAS and LAPACK",(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaLinearAlgebra/MKL.jl"},"JuliaLinearAlgebra/MKL.jl: Intel MKL linear algebra backend for Julia")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/mcabbott/Tullio.jl"},"mcabbott/Tullio.jl: \u2140")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaLinearAlgebra/Octavian.jl"},"JuliaLinearAlgebra/Octavian.jl: Multi-threaded BLAS-like library that provides pure Julia matrix multiplication")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaGPU/GemmKernels.jl"},"JuliaGPU/GemmKernels.jl: Flexible and performant GEMM kernels in Julia")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/MasonProtter/Gaius.jl"},"MasonProtter/Gaius.jl: Divide and Conquer Linear Algebra")),(0,n.kt)("h4",{id:"-eigenvalues-and-solvers-"},(0,n.kt)("span",{id:"head19"}," Eigenvalues and Solvers ")),(0,n.kt)("p",null,"Eig",(0,n.kt)("a",{parentName:"p",href:"https://github.com/nep-pack/NonlinearEigenproblems.jl"},"nep-pack/NonlinearEigenproblems.jl: Nonlinear eigenvalue problems in Julia: Iterative methods and benchmarks")),(0,n.kt)("p",null,"Solver",(0,n.kt)("a",{parentName:"p",href:"https://github.com/SciML/LinearSolve.jl"},"SciML/LinearSolve.jl: LinearSolve.jl: High-Performance Unified Linear Solvers")),(0,n.kt)("p",null,"Julia:"),(0,n.kt)("p",null,"Eig:\n",(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaLinearAlgebra/Arpack.jl"},"JuliaLinearAlgebra/Arpack.jl: Julia Wrappers for the arpack-ng Fortran library")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaLinearAlgebra/ArnoldiMethod.jl"},"JuliaLinearAlgebra/ArnoldiMethod.jl: Implicitly Restarted Arnoldi Method, natively in Julia")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/Jutho/KrylovKit.jl"},"Jutho/KrylovKit.jl: Krylov methods for linear problems, eigenvalues, singular values and matrix functions")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/pablosanjose/QuadEig.jl"},"pablosanjose/QuadEig.jl: Julia implementation of the ",(0,n.kt)("inlineCode",{parentName:"a"},"quadeig")," algorithm for the solution of quadratic matrix pencils")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaApproximation/SpectralMeasures.jl"},"JuliaApproximation/SpectralMeasures.jl: Julia package for finding the spectral measure of structured self adjoint operators")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/dgleich/GenericArpack.jl"},"dgleich/GenericArpack.jl: A pure Julia translation of the Arpack library for eigenvalues and eigenvectors but for any numeric types. (Symmetric only right now)")),(0,n.kt)("p",null,"Solver:"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaInv/KrylovMethods.jl"},"JuliaInv/KrylovMethods.jl: Simple and fast Julia implementation of Krylov subspace methods for linear systems.")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaSmoothOptimizers/Krylov.jl"},"JuliaSmoothOptimizers/Krylov.jl: A Julia Basket of Hand-Picked Krylov Methods")),(0,n.kt)("p",null,"Eig Too",(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaLinearAlgebra/IterativeSolvers.jl"},"JuliaLinearAlgebra/IterativeSolvers.jl: Iterative algorithms for solving linear systems, eigensystems, and singular value problems")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/tjdiamandis/RandomizedPreconditioners.jl"},"tjdiamandis/RandomizedPreconditioners.jl")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaLinearAlgebra/RecursiveFactorization.jl"},"JuliaLinearAlgebra/RecursiveFactorization.jl")),(0,n.kt)("p",null,"Spectral methods"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaApproximation/SpectralMeasures.jl"},"JuliaApproximation/SpectralMeasures.jl: Julia package for finding the spectral measure of structured self adjoint operators")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/tpapp/SpectralKit.jl"},"tpapp/SpectralKit.jl: Building blocks of spectral methods for Julia.")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/markmbaum/BasicInterpolators.jl"},"markmbaum/BasicInterpolators.jl: Basic (+chebyshev) interpolation recipes in Julia")),(0,n.kt)("p",null,"Spasrse Slover"),(0,n.kt)("p",null,"Sparse",(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaSparse/Pardiso.jl"},"JuliaSparse/Pardiso.jl: Calling the PARDISO library from Julia")),(0,n.kt)("p",null,"Sparse",(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaSparse/MKLSparse.jl"},"JuliaSparse/MKLSparse.jl: Make available to Julia the sparse functionality in MKL")),(0,n.kt)("p",null,"Sparse",(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaLang/SuiteSparse.jl"},"JuliaLang/SuiteSparse.jl: Development of SuiteSparse.jl, which ships as part of the Julia standard library.")),(0,n.kt)("p",null,"Python:"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.eigs.html?highlight=scipy%20sparse%20linalg%20eigs#scipy.sparse.linalg.eigs"},"scipy.sparse.linalg.eigs \u2014 SciPy v1.7.1 Manual")),(0,n.kt)("h4",{id:"maps-and-operators"},(0,n.kt)("span",{id:"head20"},"Maps and Operators")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/Jutho/LinearMaps.jl"},"Jutho/LinearMaps.jl: A Julia package for defining and working with linear maps, also known as linear transformations or linear operators acting on vectors. The only requirement for a LinearMap is that it can act on a vector (by multiplication) efficiently.")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/emmt/LazyAlgebra.jl"},"emmt/LazyAlgebra.jl: A Julia package to extend the notion of vectors and matrices")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaSmoothOptimizers/LinearOperators.jl"},"JuliaSmoothOptimizers/LinearOperators.jl: Linear Operators for Julia")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/kul-optec/AbstractOperators.jl"},"kul-optec/AbstractOperators.jl: Abstract operators for large scale optimization in Julia")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/matthieugomez/InfinitesimalGenerators.jl"},"matthieugomez/InfinitesimalGenerators.jl: A set of tools to work with Markov Processes")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/ranocha/SummationByPartsOperators.jl"},"ranocha/SummationByPartsOperators.jl: A Julia library of summation-by-parts (SBP) operators used in finite difference, Fourier pseudospectral, continuous Galerkin, and discontinuous Galerkin methods to get provably stable semidiscretizations, paying special attention to boundary conditions.")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/hakkelt/FunctionOperators.jl"},"hakkelt/FunctionOperators.jl: Julia package that allows writing code close to mathematical notation memory-efficiently.")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/JuliaApproximation/ApproxFun.jl"},"JuliaApproximation/ApproxFun.jl: Julia package for function approximation")),(0,n.kt)("h4",{id:"matrxi-equations"},(0,n.kt)("span",{id:"head21"},"Matrxi Equations")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/andreasvarga/MatrixEquations.jl"},"andreasvarga/MatrixEquations.jl: Solution of Lyapunov, Sylvester and Riccati matrix equations using Julia")),(0,n.kt)("h4",{id:"kronecker-based-algebra"},(0,n.kt)("span",{id:"head22"},"Kronecker-based algebra")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/MichielStock/Kronecker.jl"},"MichielStock/Kronecker.jl: A general-purpose toolbox for efficient Kronecker-based algebra.")))}h.isMDXComponent=!0}}]);